// SPDX-License-Identifier: MIT
// https://docs.quadrans.io/programming/solidity_101.html
//pragma solidity ^0.8.0;
pragma solidity >=0.4.22 <0.9.0;

import "./ERC721/ERC721.sol";
import "./access/AccessControlEnumerable.sol";
import "./ERC721/extensions/ERC721Enumerable.sol";
import "./ERC721/extensions/ERC721Burnable.sol";
import "./ERC721/extensions/ERC721Pausable.sol";
import "./utils/Counters.sol";
import "./utils/cryptography/ECDSA.sol";
import "./utils/math/SafeMath.sol";
import "./access/Ownable.sol";

/**
 * @dev Valorem Asset NFT
 * @author Burt Snyder / Open Zeppelin
 * Facilitate buying a percentage of real estate as an nft token.
 * - Tokens updated on appraisel
 * - ...
 */
contract VContractMultiFile is
    Context,
    AccessControlEnumerable,
    ERC721Enumerable,
    ERC721Burnable,
    ERC721Pausable,
    Ownable
{
    using Counters for Counters.Counter;
    using ECDSA for bytes32;
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    string private _baseTokenURI;

    Counters.Counter private _tokenIdTracker;

    //last token minted
    uint256 private _tokenId;

    //dev mode testing
    bool private _devMode = false;

    /**
     * @dev Asset details update purchaseAmount on transfer
     */
    struct Asset {
        string name;
        uint256 currentValue;
        uint256 usedValue;
    }

    /**
     * @dev Percentage of asset owned
     */
    struct Percentage {
        uint256 percentage;
    }

    struct TokenSaleState {
        uint256 tokenId;
        address tokenOwner;
        uint256 salePrice;
        bool forSale;
    }

    TokenSaleState[] private tknSaleState;
    Asset[] private assets;
    Percentage[] private percentages;

    //map asset to tokenId
    mapping(uint256 => uint256) public assetToToken;

    //map percentage to tokenId
    mapping(uint256 => uint256) public percentageToToken;

    //prevent re-runs
    mapping(address => mapping(uint256 => bool)) usedNonces;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev returns baseTokenUri
     */
    function getBaseTokenURI() external view returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev returns baseTokenUri
     */
    function getAssetsSize() external view returns (uint256 count) {
        return assets.length;
    }

    /**
     * @dev returns asset
     */
    function getAssetFromTokenId(uint256 tokenId)
        external
        view
        returns (
            string memory name,
            uint256 currentValue,
            uint256 usedValue
        )
    {
        uint256 _id = assetToToken[tokenId];
        Asset memory p = assets[_id];
        return (p.name, p.currentValue, p.usedValue);
    }

    /**
     * @dev returns asset
     */
    function getAssetFromStructIndex(uint256 index)
        external
        view
        returns (
            string memory name,
            uint256 currentValue,
            uint256 usedValue
        )
    {
        Asset memory p = assets[index];
        return (p.name, p.currentValue, p.usedValue);
    }

    /**
     * @dev returns asset currentValue
     */
    function getAssetCurrentValue(uint256 tokenId)
        external
        view
        returns (uint256 currentValue)
    {
        uint256 _id = assetToToken[tokenId];
        Asset memory p = assets[_id];
        return p.currentValue;
    }

    /**
     * @dev returns asset usedValue (1-100 %)
     */
    function getAssetUsedValue(uint256 tokenId)
        external
        view
        returns (uint256 usedValue)
    {
        uint256 _id = assetToToken[tokenId];
        Asset memory p = assets[_id];
        return p.usedValue;
    }

    /**
     * @dev returns asset Name
     */
    function getAssetName(uint256 tokenId)
        external
        view
        returns (string memory name)
    {
        uint256 _id = assetToToken[tokenId];
        Asset memory p = assets[_id];
        return p.name;
    }

    /**
     * @dev update _baseTokenURI
     */
    function updateBaseTokenURI(
        string memory _uri,
        bytes32 message,
        uint256 nonce,
        bytes memory signature
    ) external {
        require(
            _isOwner(message, nonce, signature),
            "VContract: Not Authorized to Update Asset Uri"
        );
        _baseTokenURI = _uri;
    }

    /**
     * @dev private add new asset uri to mapping set on mint
     */
    function _setAssetOnMint(
        uint256 tokenId,
        string memory _name,
        uint256 _currentValue,
        uint256 _percentage
    ) internal {
        assets.push(Asset(_name, _currentValue, _percentage));
        uint256 id = assets.length - 1;
        assetToToken[tokenId] = id;
    }

    /**
     * @dev private add new asset uri to mapping set on mint
     */
    function _setExistingAssetOnMint(
        uint256 tokenId,
        uint256 assetIndex,
        uint256 percentage
    ) internal returns (bool) {
        Asset storage _asset = assets[assetIndex];
        uint256 currentValue = _asset.usedValue;
        uint256 result = currentValue.add(percentage);
        if (result <= 10000) {
            //if (result < 10000 || result == 10000) {
            //truffle compiler issue with <= and EVM possible
            _asset.usedValue = result;
            assets[assetIndex] = _asset;
            assetToToken[tokenId] = assetIndex;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev set percentage value of asset
     */
    function getPercentageValueOfAsset(uint256 tokenId)
        external
        view
        returns (uint256 percentage)
    {
        uint256 _assetId = assetToToken[tokenId];
        Asset storage _asset = assets[_assetId];
        uint256 _currentValue = _asset.currentValue;

        uint256 _percentageId = percentageToToken[tokenId];
        Percentage storage _p = percentages[_percentageId];
        uint256 _percentage = _p.percentage;

        uint256 basispoint = _percentage;
        return calculateAssetPercentage(_currentValue, basispoint);
    }

    /**
     * @dev update asset currentValue on appraisal
     */
    function updateAssetCurrentValue(
        uint256 index,
        uint256 _currentValue,
        bytes32 message,
        uint256 nonce,
        bytes memory signature
    ) external {
        require(
            _isOwner(message, nonce, signature),
            "VContract: Not Authorized to Update Asset Value"
        );
        Asset storage _asset = assets[index];
        _asset.currentValue = _currentValue;
        assets[index] = _asset;
    }

    /**
     * @dev update asset name
     * TODO:
     */
    function updateAssetName(
        uint256 index,
        string memory _name,
        bytes32 message,
        uint256 nonce,
        bytes memory signature
    ) external {
        require(
            _isOwner(message, nonce, signature),
            "VContract: Not Authorized to Update Asset Name"
        );
        Asset storage _asset = assets[index];
        _asset.name = _name;
        assets[index] = _asset;
    }

    /**
     * @dev private add new asset uri to mapping set on mint
     */
    function _setPercentageOnMint(uint256 tokenId, uint256 _percentage)
        internal
    {
        percentages.push(Percentage(_percentage));
        uint256 id = percentages.length - 1;
        percentageToToken[tokenId] = id;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must be authorized to mint via _isOwner
     *
     * Extra:
     * - set last token minted: _tokenId
     * - set asset uri address if you want or value to add to base
     */
    function mint(
        address to,
        bool newAsset, // new or existing asset?
        uint256 assetIndex, // if existing what index?
        string memory _assetName,
        uint256 _currentValue, //ethers.utils.parseUnits(n, 2)
        uint256 _percentage,
        bytes32 message,
        uint256 nonce,
        bytes memory signature
    ) public virtual {
        require(
            _isOwner(message, nonce, signature),
            "VContract: Not Authorized to Mint"
        );
        _mint(to, _tokenIdTracker.current());
        _tokenId = _tokenIdTracker.current();

        if (newAsset) {
            _setAssetOnMint(
                _tokenIdTracker.current(),
                _assetName,
                _currentValue,
                _percentage
            );
        } else {
            require(
                _setExistingAssetOnMint(
                    _tokenIdTracker.current(),
                    assetIndex,
                    _percentage
                ),
                "VContract: Asset % Exceeds Availablity"
            );
            Asset storage _asset = assets[assetIndex];
            _currentValue = _asset.currentValue;
        }
        _setPercentageOnMint(_tokenIdTracker.current(), _percentage);

        _tokenIdTracker.increment();
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    // added for relay services i.e. itx infura
    // _msgSender not same set in constructor for
    // future transactions ... now they have a new deploy method ...
    function _isOwner(
        bytes32 message,
        uint256 nonce,
        bytes memory signature
    ) internal returns (bool) {
        if (_devMode) return true;
        require(!usedNonces[owner()][nonce], "Vcontract: Bad Nonce");
        address signer = ECDSA.recover(message, signature);
        if (signer == owner()) {
            usedNonces[signer][nonce] = true;
            return true;
        } else {
            return false;
        }
    }

    function getOwner() external view returns (address) {
        return owner();
    }

    //https://www.omnicalculator.com/finance/basis-point
    //https://www.investopedia.com/ask/answers/what-basis-point-bps/
    // find basis point from percentage by > percentage * 100
    // .i.e 0.5 * 100 = 50 bps
    function calculateAssetPercentage(uint256 amount, uint256 basispoint)
        internal
        pure
        returns (uint256)
    {
        //theNumber is never a decimal
        return amount.mul(basispoint).div(10000); //returns bps add .00
    }

    /**
     * @dev
     * returns the last id of minted token
     */
    function lastTokenMinted() public view returns (uint256) {
        // return BN { negative: 0, words: [ 3, <1 empty item> ], length: 1, red: null }
        return _tokenId;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControlEnumerable, ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
